# 📌 언어별 패키지 매니저 완벽 가이드

## 📍 선정 기준 4대 원칙

### 1. 신뢰성 관점
- **의존성 해결**: 복잡한 의존성을 정확히 처리하는가
- **보안**: 패키지 검증 시스템이 있는가
- **안정성**: 버그나 충돌 없이 작동하는가

### 2. 전략적 관점
- **생태계 지배력**: 해당 언어 커뮤니티 표준인가
- **기업 지원**: 대기업이나 재단의 백업이 있는가
- **미래 전망**: 계속 발전할 가능성이 높은가

### 3. 기술적 관점
- **성능**: 설치/업데이트 속도가 빠른가
- **기능**: 버전 관리, 스크립트 실행 등 부가 기능
- **호환성**: 다른 도구들과 잘 연동되는가

### 4. 브랜딩 관점
- **학습 비용**: 배우기 쉽고 문서가 잘 되어 있는가
- **인력 확보**: 해당 도구를 아는 개발자가 많은가
- **표준화**: 팀 내 통일된 환경 구축 가능한가

---

## 📍 Python 생태계

### pip (기존 표준)
- **출시**: 2008년
- **구현**: Python
- **특징**: 가장 기본적인 도구
- **장점**:
  - 모든 Python 환경에 기본 포함
  - 15년간 축적된 안정성
  - 모든 튜토리얼에서 사용
- **단점**:
  - 매우 느림 (Python으로 구현)
  - 의존성 충돌 해결 부족
  - 가상환경 관리 별도 필요

### uv (신세대 고속 도구) ⭐ **추천**
- **출시**: 2024년
- **구현**: Rust
- **특징**: pip 호환 + 초고속
- **장점**:
  - 10-100배 빠른 속도
  - pip와 100% 호환
  - 가상환경 통합 관리
  - 프로젝트 관리 기능
- **단점**:
  - 상대적으로 새로운 도구
  - 일부 edge case 존재 가능

### poetry (프로젝트 관리 특화)
- **출시**: 2018년
- **구현**: Python
- **특징**: 의존성 + 빌드 + 배포 통합
- **장점**:
  - pyproject.toml 표준 지원
  - 정확한 의존성 락 파일
  - 빌드/배포 자동화
- **단점**:
  - 학습 곡선 존재
  - 때로는 과도한 기능

### conda (과학 컴퓨팅)
- **출시**: 2012년
- **구현**: Python
- **특징**: Python + 시스템 패키지
- **장점**:
  - NumPy, SciPy 등 과학 라이브러리 특화
  - 바이너리 패키지 제공
  - 환경 격리 우수
- **단점**:
  - 용량 큰 설치
  - pip와 혼용시 충돌 가능

**Python 결론**: uv (속도) > poetry (프로젝트 관리) > pip (호환성) > conda (과학용)

---

## 📍 Node.js 생태계

### npm (기본 표준)
- **출시**: 2010년
- **구현**: JavaScript
- **특징**: Node.js 기본 포함
- **장점**:
  - Node.js 설치시 자동 포함
  - 가장 큰 패키지 레지스트리
  - 모든 도구와 호환
- **단점**:
  - node_modules 중복 문제
  - 상대적으로 느린 속도
  - 보안 취약점 과거 존재

### yarn (페이스북 개발) 
- **출시**: 2016년
- **구현**: JavaScript
- **특징**: npm 호환 + 성능 개선
- **장점**:
  - npm보다 빠른 속도
  - 락 파일 자동 생성
  - 오프라인 캐시 지원
- **단점**:
  - 추가 설치 필요
  - yarn.lock 파일 관리

### pnpm (디스크 효율성) ⭐ **추천**
- **출시**: 2017년
- **구현**: JavaScript
- **특징**: 심볼릭 링크 활용
- **장점**:
  - 디스크 공간 최대 70% 절약
  - npm보다 2-3배 빠름
  - 엄격한 의존성 관리
- **단점**:
  - 일부 도구와 호환성 이슈
  - Windows 심볼릭 링크 제한

### bun (올인원 런타임)
- **출시**: 2022년
- **구현**: Zig
- **특징**: 런타임 + 패키지 매니저
- **장점**:
  - 극도로 빠른 속도
  - TypeScript 네이티브 지원
  - 올인원 도구
- **단점**:
  - 아직 실험적 단계
  - Node.js 완전 호환성 미보장

**Node.js 결론**: pnpm (효율성) > yarn (안정성) > npm (호환성) > bun (실험용)

---

## 📍 PHP 생태계

### Composer (사실상 표준) ⭐ **유일한 선택**
- **출시**: 2012년
- **구현**: PHP
- **특징**: PSR 표준 준수
- **장점**:
  - PHP 생태계 사실상 표준
  - 오토로딩 자동 생성
  - 버전 의존성 정확한 해결
- **단점**:
  - 메모리 사용량 큼
  - 대용량 프로젝트에서 느림

**PHP 결론**: Composer 외에는 실질적 대안 없음

---

## 📍 Ruby 생태계

### RubyGems (gem) (기본)
- **출시**: 2004년
- **구현**: Ruby
- **특징**: Ruby 기본 포함
- **장점**:
  - Ruby 설치시 자동 포함
  - 간단한 사용법
  - 중앙 저장소 운영
- **단점**:
  - 전역 설치로 인한 충돌
  - 의존성 해결 부족

### Bundler (프로젝트 관리) ⭐ **추천**
- **출시**: 2010년
- **구현**: Ruby
- **특징**: Gemfile 기반 관리
- **장점**:
  - 정확한 버전 고정
  - 프로젝트별 의존성 격리
  - Rails 표준 도구
- **단점**:
  - gem과 별도 학습 필요
  - 설정 파일 관리

**Ruby 결론**: Bundler + gem 조합이 표준

---

## 📍 Go 생태계

### Go Modules (공식) ⭐ **유일한 선택**
- **출시**: 2019년 (Go 1.13+)
- **구현**: Go
- **특징**: 언어 레벨 통합
- **장점**:
  - 언어에 내장
  - 시맨틱 버저닝 강제
  - 미니멀한 설계
- **단점**:
  - 상대적으로 기능 제한적
  - 프록시 서버 의존성

**Go 결론**: Go Modules 외에는 선택의 여지 없음

---

## 📍 Rust 생태계

### Cargo (공식) ⭐ **유일한 선택**
- **출시**: 2014년
- **구현**: Rust
- **특징**: 빌드 시스템 통합
- **장점**:
  - 빌드, 테스트, 패키지 관리 통합
  - 강력한 의존성 해결
  - 워크스페이스 지원
- **단점**:
  - 컴파일 시간 길어질 수 있음
  - 학습 곡선 존재

**Rust 결론**: Cargo 외에는 대안 없음

---

## 📍 Java 생태계

### Maven (기업 표준)
- **출시**: 2004년
- **구현**: Java
- **특징**: XML 기반 설정
- **장점**:
  - 기업 환경 표준
  - 강력한 라이프사이클 관리
  - 플러그인 생태계 풍부
- **단점**:
  - XML 설정 복잡
  - 학습 곡선 가파름

### Gradle (최신 표준) ⭐ **추천**
- **출시**: 2012년
- **구현**: Groovy/Kotlin
- **특징**: 스크립트 기반 빌드
- **장점**:
  - 유연한 빌드 스크립트
  - Maven보다 빠른 성능
  - Android 공식 빌드 도구
- **단점**:
  - 메모리 사용량 많음
  - 복잡한 설정 가능

### SBT (Scala 특화)
- **출시**: 2008년
- **구현**: Scala
- **특징**: Scala 생태계 표준
- **장점**:
  - Scala 프로젝트 최적화
  - 인크리멘탈 컴파일
- **단점**:
  - Scala 외에는 사용 제한적

**Java 결론**: Gradle (현대적) > Maven (안정성) > SBT (Scala 전용)

---

## 📍 언어별 최종 추천

| 언어 | 1순위 | 2순위 | 3순위 | 특수 용도 |
|---|---|---|---|---|
| **Python** | uv | poetry | pip | conda (과학용) |
| **Node.js** | pnpm | yarn | npm | bun (실험용) |
| **PHP** | Composer | - | - | - |
| **Ruby** | Bundler+gem | gem | - | - |
| **Go** | Go Modules | - | - | - |
| **Rust** | Cargo | - | - | - |
| **Java** | Gradle | Maven | SBT | - |

---

## 📍 선택 가이드라인

### 신규 프로젝트
1. **성능 우선**: uv, pnpm, Gradle
2. **안정성 우선**: pip, npm, Maven  
3. **팀 표준**: 기존 팀이 사용하는 도구

### 기존 프로젝트
1. **마이그레이션 비용** 고려
2. **하위 호환성** 확인
3. **점진적 전환** 계획

## ✅ 체크리스트
- [ ] 사용하는 언어의 패키지 매니저 현황 파악
- [ ] 팀 내 표준 도구 확인
- [ ] 성능 vs 안정성 우선순위 결정
- [ ] 마이그레이션 계획 수립 (필요시)

**다음 단계**: 특정 언어의 패키지 매니저 심화 가이드 및 마이그레이션 방법
